= Customize Identifier Parsing in a Groovy DSL
Matthew Borger <matthew@borgernet.com>
2017-04-17
:icons: font

I had just created what I thought to be the perfect domain specific language.
It had fluent method chaining and closure configurations, all the cool tricks to create a natural DSL.
There was only one sticking point that kept bothering me - the user defined names had to be valid groovy identifiers.
At first, I thought this was no problem.
Who would name things with weird characters like `<` or `-`?
It turns out my customers in the genetics business do exactly that!
They have assays with wonderful names such as `RS123A->C`.
Thus began my quest to fix those identifiers for my DSL.

== My Ideal DSL
My perfect DSL needs not to remind the user that they're writing code but rather describing their domain.

[source,groovy]
----
assay RS123A->C

compositeAssay RS456-789 with {
    assay RS123A->C
}
----

Ideally, I want to define an identifier named `RS123A->C` so I can take advantage of static typing.
It would be great if I could modify the token parsing phase so characters that are normally treated as operators can be considered part of the identifier.
One of Groovy's selling points is that there are hooks available for modifying the compilation process.
Most of the documentation out on the Internet deals with creating abstract syntax tree transformations which is too late to make these identifier modifications.
I need to modify the concrete syntax tree which Groovy exposes modification to by providing a custom `ParserPlugin`.
Since Groovy migrated to ANTLR it seems much more difficult to make modifications during tokenization before the AST is generated and the most basic grammar rules, such as taking `-` to subtract two identifiers, kick in causing the above to light up with errors.
With that in mind, I opted to modify the source before tokenization.

== Rewriting your Code
The goal of modifying the source is to recognize certain strings as identifiers.
To do this without modifying Groovy we need to rewrite these "certain strings" into identifiers.
I created a parser plugin that you can register regular expressions with based on a method name and one or many end tokens.

Essentially, the parser will rewrite the above source.

[source,groovy]
----
assay __var1

compositeAssay __var2 with {
    assay __var1
}
----

Now that we have valid Groovy identifiers, the next piece is to provide the original strings to the calling methods.
To accomplish the translation back to the original string I used Groovy's `propertyMissing` method to return the original string for translated extended identifiers.

.DslScript.groovy
[source,groovy]
----
def propertyMissing(String propertyName) {
    if (isExtendedIdentifier(propertyName))
        return decodeExtendedIdentifier(propertyName)
    throw new MissingPropertyException(propertyName, Void)
}
----

== Setting up the Parser
Before you can parse any DSL scripts, you need to configure the parser with what methods work with extended identifiers.
Suppose you had the following DSL script.

.Script.dsl
----
assay RS123A->C

compositeAssay RS456-789 with {
    assay RS123A->C
}

compositeAssay *&<>WeirdName-_>

manuallySpecifiedPatternMethod RS123A->C
----

We want the usages of the `assay`, `compositeAssay` and `manuallySpecifiedPatternMethod` to treat their arguments as extended identifiers.
For this scenario the Groovy shell could be configured as follows.

.DSL Parsing Configuration
[source,groovy]
----
def conf = new CompilerConfiguration()
conf.scriptBaseClass = Dsl.name
conf.pluginFactory = {
        def parser = new ExtendedIdentifierParser()
        parser.scanPackage("my.dsl") // <1>
        parser.addPattern("manuallySpecifiedPatternMethod") // <2>
        parser
}
def binding = new DslBinding() // <3>
def shell = new GroovyShell(this.class.classLoader, binding, conf)
----
<1> Instructs the parser to register method translation patterns based upon annotations. How these work are discussed below.
<2> Instruct the parser to treat the rest of the line after "manuallySpecifiedPatternMethod" as an extended identifier.
<3> Use our custom Binding implementation to register variables using extended identifiers.







////
== Annotating your Expectations
The next piece involves setting up an annotation that can be used to mark which methods that should support the extended identifier syntax.

[source,groovy]
----
abstract class Dsl extends DslScript {
    Set<Assay> assays = new HashSet<>()
    Set<CompositeAssay> compositeAssays = new HashSet<>();

    @ExtendedStringParameter <1>
    def assay(String name) {
        def assay = new Assay(name: name)
        assays.add(assay)
        getBinding().setVariable(name, assay)
        assay
    }

    @ExtendedStringParameter(endTokens = [EOL, "with"]) <2>
    def compositeAssay(String name) {
        def compositeAssay = new CompositeAssay(name: name)
        compositeAssays.add(compositeAssay)
        getBinding().setVariable(name, compositeAssay)
        compositeAssay
    }

}

class CompositeAssay {
    String name
    private Assay assay

    def assay(Assay assay) { <3>
        this.assay = assay
    }
}
----
<1> By default the `@ExtendedStringParameter` will glob the rest of the line as the string argument.
<2> Or you can specify what tokens demarcate the end of the identifier, non inclusive.
<3> This method would have to be annotated if the method name was different from what defined `Assay`s.

When constructing the parser plugin, a package must be provided to scan for usages of the `@ExtendedStringParameter` annotation.

[source,java]
----
public class ExtendedStringParameterParser extends AntlrParserPlugin {

    private static final String identifierPattern = "\\s+(\\S.*\\S)\\s*";

    private Collection<Pattern> methodPatterns = new LinkedList<>();

    public ExtendedStringParameterParser(String packageName) {
        FastClasspathScanner classpathScanner = new FastClasspathScanner(packageName);
        classpathScanner.matchClassesWithMethodAnnotation(ExtendedStringParameter.class,
                ((matchingClass, matchingMethod) -> {
                    ExtendedStringParameter annotation = matchingMethod.getAnnotation(ExtendedStringParameter.class);
                    storeMethodPatterns(matchingMethod.getName(), annotation.endTokens());
                }));
        classpathScanner.scan();
    }

    private void storeMethodPatterns(String methodName, String[] endTokens) {
        String patternStart = methodName + identifierPattern;
        Arrays.stream(endTokens)
                .sorted(this::preferNonEOLTokens)
                .forEach(endToken -> methodPatterns.add(Pattern.compile(patternStart + endToken)));
    }

    /**
     * Always order a non EOL token after anything else.
     */
    private int preferNonEOLTokens(String o1, String o2) {
        if (EOL.equals(o1)) return 1;
        if (EOL.equals(o2)) return -1;
        return 0;
    }
----

== Handling the unknown identifiers
Now that the identifiers have been converted to hexadecimal, the script needs some plumbing to pick those up and translate them into their original strings.
Groovy provides some metaprogramming methods such as `propertyMissing`.
If the identifier starts with the special marker then the original string value is decoded and stored in a special property using another metaprogramming facility by adding new metaclass methods to Strings.
This idea of the `DslScript` class is that your DSL will extend it.
These patterns come from the book, https://www.packtpub.com/application-development/groovy-domain-specific-languages-second-edition[Groovy for Domain-specific languages].

[source,groovy]
----
abstract class DslScript extends Script {

    def static identifierProperties = Collections.synchronizedMap([:])

    static {
        String.metaClass.setBindingValue = { String value ->
            identifierProperties[identityHashCode(delegate)] = value
        }
        String.metaClass.getBindingValue = { ->
            identifierProperties[identityHashCode(delegate)]
        }
    }

    def propertyMissing(String propertyName) {
        if (propertyName.startsWith(IDENTIFIER_MARKER)) {
            def identifier = new String(propertyName.substring(IDENTIFIER_MARKER.length()).decodeHex())
            identifier.setBindingValue(propertyName)
            return identifier
        }
        propertyName
    }

}
----

In addition the `Binding` needs to be extended to store variables by their hexadecimal form so other methods can take advantage of strong typing.

[source,groovy]
----
class DslBinding extends Binding {

    @Override
    void setVariable(String name, Object value) {
        String bindingValue = name.getBindingValue()
        if (bindingValue != null) {
            super.setVariable(bindingValue, value)
        } else {
            super.setVariable(name, value)
        }
    }

}
----

== Tying it all together
Finally the DSL can be executed by configuring the `GroovyShell` with all the pieces.

[source,groovy]
----
def conf = new CompilerConfiguration()
conf.scriptBaseClass = Dsl.name
conf.pluginFactory = new ParserPluginFactory() {
    @Override
    ParserPlugin createParserPlugin() {
        new ExtendedStringParameterParser("my.dsl")
    }
}
def binding = new DslBinding()
def shell = new GroovyShell(this.class.classLoader, binding, conf)
Dsl result = shell.parse(new InputStreamReader(this.class.classLoader.getResourceAsStream("Script.dsl"))) as Dsl
result.run()
----

If you made it this far, check out the source.
////
